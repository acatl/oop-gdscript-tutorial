# Final Game: Tiny Town RPG ğŸ®

By the end of the tutorial, students will have built a complete (but simple) RPG called **Tiny Town RPG**, featuring:

## ğŸ§™ Main Features

- **Playable Hero** with health, healing, damage, and leveling up
- **Enemy Characters** with health and death logic
- **Villagers** with custom names and optional dialogue
- **Quests** that provide XP when completed
- **Signals** to decouple UI from logic (e.g. health bars, level-ups)
- **Clean Code** practices including:

  - Good naming
  - SRP (Single Responsibility Principle)
  - Small functions

- **Refactored Combat System** using shared `Character.gd`

## ğŸ“š What Students Practice

- Class design and instancing
- Inheritance and composition
- Event-driven programming (signals)
- Debugging and testing
- Creating interactive UI
- Code organization and responsibility

## ğŸ’¬ Optional Features (Advanced Modules)

- **Basic AI** for enemies (patrol, chase)
- **Inventory System** with collectible items
- **Save/Load** feature using JSON and FileAccess

## ğŸ§  Learning Philosophy

The game is intentionally lightweight and expandable, so students:

- Feel proud of completing a â€œreal gameâ€ ğŸ‰
- Can _easily_ continue building on it
- Learn OOP the _right_ wayâ€”without overengineering
- Pick up Clean Code habits _naturally_ from the start

## ğŸªœ Suggested Post-Tutorial Next Steps

At the end of the tutorial, students will receive:

- A few fun feature ideas framed as **user stories**
- Gentle exposure to Agile thinking (epics, backlog)
- A feeling that _this is just the beginning_ ğŸ› ï¸
